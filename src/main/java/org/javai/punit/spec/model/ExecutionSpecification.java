package org.javai.punit.spec.model;

import java.time.Instant;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * An execution specification containing empirical data for probabilistic testing.
 *
 * <p>Specifications are the unified artifact that drives probabilistic tests. They contain:
 * <ul>
 *   <li><strong>Empirical basis</strong>: Raw observations (samples, successes) from experiments,
 *       used for threshold derivation at runtime</li>
 *   <li><strong>Configuration</strong>: Context for test execution (model, temperature, etc.)</li>
 *   <li><strong>Cost envelope</strong>: Resource limits (time, tokens)</li>
 *   <li><strong>Extended statistics</strong>: Optional detailed metrics (failure distribution, etc.)</li>
 * </ul>
 *
 * <h2>Simplified Workflow</h2>
 * <p>Specs are generated directly by experiments and committed to version control.
 * Approval happens through Git commit (with optional PR review). There is no separate
 * "baseline" artifact or approval command.
 *
 * <h2>Threshold Derivation</h2>
 * <p>The specification does <em>not</em> contain pre-computed thresholds. Instead,
 * thresholds are derived at test runtime based on the empirical basis and the
 * operational approach specified in the {@code @ProbabilisticTest} annotation.
 *
 * <h2>Schema Versions</h2>
 * <ul>
 *   <li>{@code punit-spec-1}: Original format with required approval metadata</li>
 *   <li>{@code punit-spec-2}: Simplified format with optional approval metadata</li>
 * </ul>
 */
public final class ExecutionSpecification {

	private final String specId;
	private final String useCaseId;
	private final int version;
	private final Instant generatedAt;
	private final Instant approvedAt;
	private final String approvedBy;
	private final String approvalNotes;
	private final List<String> sourceBaselines;
	private final Map<String, Object> executionContext;
	private final SpecRequirements requirements;
	private final CostEnvelope costEnvelope;
	private final EmpiricalBasis empiricalBasis;
	private final ExtendedStatistics extendedStatistics;

	private ExecutionSpecification(Builder builder) {
		this.specId = Objects.requireNonNull(builder.specId, "specId must not be null");
		this.useCaseId = Objects.requireNonNull(builder.useCaseId, "useCaseId must not be null");
		this.version = builder.version;
		this.generatedAt = builder.generatedAt;
		this.approvedAt = builder.approvedAt;
		this.approvedBy = builder.approvedBy;
		this.approvalNotes = builder.approvalNotes;
		this.sourceBaselines = builder.sourceBaselines != null
				? List.copyOf(builder.sourceBaselines)
				: Collections.emptyList();
		this.executionContext = builder.executionContext != null
				? Collections.unmodifiableMap(new LinkedHashMap<>(builder.executionContext))
				: Collections.emptyMap();
		this.requirements = builder.requirements != null
				? builder.requirements
				: new SpecRequirements(1.0, "");
		this.costEnvelope = builder.costEnvelope;
		this.empiricalBasis = builder.empiricalBasis;
		this.extendedStatistics = builder.extendedStatistics;
	}

	public static Builder builder() {
		return new Builder();
	}

	public String getSpecId() {
		return specId;
	}

	public String getUseCaseId() {
		return useCaseId;
	}

	public int getVersion() {
		return version;
	}

	/**
	 * Returns when this specification was generated by an experiment.
	 *
	 * @return the generation timestamp, or null if not recorded
	 */
	public Instant getGeneratedAt() {
		return generatedAt;
	}

	/**
	 * Returns when this specification was approved.
	 *
	 * <p>Note: In the simplified workflow (punit-spec-2), approval metadata is optional
	 * since approval happens through Git commit. This field may be null.
	 *
	 * @return the approval timestamp, or null if not recorded
	 */
	public Instant getApprovedAt() {
		return approvedAt;
	}

	/**
	 * Returns who approved this specification.
	 *
	 * <p>Note: In the simplified workflow (punit-spec-2), approval metadata is optional
	 * since approval happens through Git commit. This field may be null.
	 *
	 * @return the approver name, or null if not recorded
	 */
	public String getApprovedBy() {
		return approvedBy;
	}

	public String getApprovalNotes() {
		return approvalNotes;
	}

	public List<String> getSourceBaselines() {
		return sourceBaselines;
	}

	public Map<String, Object> getExecutionContext() {
		return executionContext;
	}

	public SpecRequirements getRequirements() {
		return requirements;
	}

	public CostEnvelope getCostEnvelope() {
		return costEnvelope;
	}

	/**
	 * Returns the empirical basis used for threshold derivation.
	 *
	 * <p>This data is essential for computing thresholds at runtime based on
	 * the operational approach specified in the test annotation.
	 *
	 * @return the empirical basis, or null if not set (legacy specs)
	 */
	public EmpiricalBasis getEmpiricalBasis() {
		return empiricalBasis;
	}

	/**
	 * Returns the raw baseline data used for threshold derivation.
	 *
	 * @return the baseline data, or null if not set (legacy specs)
	 * @deprecated Use {@link #getEmpiricalBasis()} instead
	 */
	@Deprecated(since = "0.2.0", forRemoval = true)
	public EmpiricalBasis getBaselineData() {
		return empiricalBasis;
	}

	/**
	 * Returns extended statistics from the experiment.
	 *
	 * <p>This optional data provides additional detail for analysis but is not
	 * required for threshold derivation.
	 *
	 * @return extended statistics, or null if not recorded
	 */
	public ExtendedStatistics getExtendedStatistics() {
		return extendedStatistics;
	}

	/**
	 * Returns true if this specification has empirical basis for threshold derivation.
	 *
	 * @return true if empirical basis is present
	 */
	public boolean hasEmpiricalBasis() {
		return empiricalBasis != null && empiricalBasis.samples() > 0;
	}

	/**
	 * Returns true if this specification has baseline data for threshold derivation.
	 *
	 * @return true if baseline data is present
	 * @deprecated Use {@link #hasEmpiricalBasis()} instead
	 */
	@Deprecated(since = "0.2.0", forRemoval = true)
	public boolean hasBaselineData() {
		return hasEmpiricalBasis();
	}

	/**
	 * Returns the number of samples from the baseline experiment.
	 *
	 * @return the baseline sample count, or 0 if no empirical basis
	 */
	public int getBaselineSamples() {
		return empiricalBasis != null ? empiricalBasis.samples() : 0;
	}

	/**
	 * Returns the number of successes from the baseline experiment.
	 *
	 * @return the baseline success count, or 0 if no empirical basis
	 */
	public int getBaselineSuccesses() {
		return empiricalBasis != null ? empiricalBasis.successes() : 0;
	}

	/**
	 * Returns the observed success rate from the baseline experiment.
	 *
	 * @return the observed rate (0.0 to 1.0), or 0.0 if no empirical basis
	 */
	public double getObservedRate() {
		if (empiricalBasis == null || empiricalBasis.samples() == 0) {
			return 0.0;
		}
		return (double) empiricalBasis.successes() / empiricalBasis.samples();
	}

	/**
	 * Returns true if this specification has explicit approval metadata.
	 *
	 * <p>Note: In the simplified workflow (punit-spec-2), approval metadata is optional.
	 * A spec without explicit approval is still valid if it has empirical basis.
	 *
	 * @return true if approval metadata is present
	 */
	public boolean hasApprovalMetadata() {
		return approvedAt != null && approvedBy != null && !approvedBy.isEmpty();
	}

	/**
	 * Returns true if this specification has valid approval metadata.
	 *
	 * @return true if approved
	 * @deprecated Use {@link #hasApprovalMetadata()} instead. Approval is now optional.
	 */
	@Deprecated(since = "0.2.0", forRemoval = true)
	public boolean isApproved() {
		return hasApprovalMetadata();
	}

	/**
	 * Returns the minimum pass rate from requirements.
	 *
	 * @return the minimum pass rate
	 */
	public double getMinPassRate() {
		return requirements.minPassRate();
	}

	/**
	 * Returns the success criteria from requirements.
	 *
	 * @return the success criteria
	 */
	public SuccessCriteria getSuccessCriteria() {
		String criteria = requirements.successCriteria();
		if (criteria == null || criteria.isEmpty()) {
			return SuccessCriteria.alwaysTrue();
		}
		return SuccessCriteria.parse(criteria);
	}

	/**
	 * Validates this specification.
	 *
	 * <p>Validation rules:
	 * <ul>
	 *   <li>For schema v1: approval metadata is required</li>
	 *   <li>For schema v2: empirical basis is required, approval is optional</li>
	 *   <li>minPassRate must be in range [0.0, 1.0]</li>
	 * </ul>
	 *
	 * @throws SpecificationValidationException if validation fails
	 */
	public void validate() throws SpecificationValidationException {
		// Check minPassRate bounds
		if (requirements.minPassRate() < 0.0 || requirements.minPassRate() > 1.0) {
			throw new SpecificationValidationException(
					"Specification '" + specId + "' has invalid minPassRate: " + requirements.minPassRate());
		}

		// For backwards compatibility: if approval metadata is present, it's valid
		// For new specs: empirical basis is preferred but not strictly required
		// This allows both v1 (approval-based) and v2 (empirical-based) specs
		
		// Note: We don't require approval metadata anymore for v2 specs.
		// The presence of the spec in version control IS the approval.
	}

	/**
	 * Validates this specification with strict v1 rules (approval required).
	 *
	 * @throws SpecificationValidationException if validation fails
	 * @deprecated Use {@link #validate()} instead. Approval is now optional.
	 */
	@Deprecated(since = "0.2.0", forRemoval = true)
	public void validateStrict() throws SpecificationValidationException {
		if (!hasApprovalMetadata()) {
			throw new SpecificationValidationException(
					"Specification '" + specId + "' lacks approval metadata. " +
							"Add 'approvedAt', 'approvedBy', and 'approvalNotes' to the specification file.");
		}
		validate();
	}

	/**
	 * Specification requirements.
	 */
	public record SpecRequirements(double minPassRate, String successCriteria) {
	}

	/**
	 * Cost envelope for resource limits.
	 */
	public record CostEnvelope(long maxTimePerSampleMs, long maxTokensPerSample, long totalTokenBudget) {
	}

	/**
	 * Empirical basis from the experiment, used for threshold derivation at runtime.
	 *
	 * <p>This record contains the essential observations needed to compute
	 * statistically-sound thresholds based on the operational approach.
	 *
	 * @param samples Total number of trials in the experiment
	 * @param successes Number of successful trials
	 * @param generatedAt When the experiment was run
	 */
	public record EmpiricalBasis(int samples, int successes, Instant generatedAt) {

		/**
		 * Returns the observed success rate.
		 *
		 * @return the rate (0.0 to 1.0)
		 */
		public double observedRate() {
			if (samples == 0) return 0.0;
			return (double) successes / samples;
		}

		/**
		 * Validates that the empirical basis is consistent.
		 *
		 * @throws IllegalArgumentException if data is invalid
		 */
		public EmpiricalBasis {
			if (samples < 0) {
				throw new IllegalArgumentException("samples must be non-negative");
			}
			if (successes < 0) {
				throw new IllegalArgumentException("successes must be non-negative");
			}
			if (successes > samples) {
				throw new IllegalArgumentException("successes cannot exceed samples");
			}
		}
	}

	/**
	 * Alias for EmpiricalBasis for backwards compatibility.
	 *
	 * @deprecated Use {@link EmpiricalBasis} instead
	 */
	@Deprecated(since = "0.2.0", forRemoval = true)
	public record BaselineData(int samples, int successes, Instant generatedAt) {

		/**
		 * Returns the observed success rate.
		 *
		 * @return the rate (0.0 to 1.0)
		 */
		public double observedRate() {
			if (samples == 0) return 0.0;
			return (double) successes / samples;
		}

		/**
		 * Validates that the baseline data is consistent.
		 *
		 * @throws IllegalArgumentException if data is invalid
		 */
		public BaselineData {
			if (samples < 0) {
				throw new IllegalArgumentException("samples must be non-negative");
			}
			if (successes < 0) {
				throw new IllegalArgumentException("successes must be non-negative");
			}
			if (successes > samples) {
				throw new IllegalArgumentException("successes cannot exceed samples");
			}
		}
	}

	/**
	 * Extended statistics from the experiment.
	 *
	 * <p>This data provides additional detail for analysis but is not required
	 * for threshold derivation.
	 *
	 * @param standardError Standard error of the observed rate
	 * @param confidenceIntervalLower Lower bound of 95% confidence interval
	 * @param confidenceIntervalUpper Upper bound of 95% confidence interval
	 * @param failureDistribution Count of failures by category
	 * @param totalTimeMs Total experiment execution time
	 * @param avgTimePerSampleMs Average time per sample
	 * @param totalTokens Total tokens consumed
	 * @param avgTokensPerSample Average tokens per sample
	 */
	public record ExtendedStatistics(
			double standardError,
			double confidenceIntervalLower,
			double confidenceIntervalUpper,
			Map<String, Integer> failureDistribution,
			long totalTimeMs,
			long avgTimePerSampleMs,
			long totalTokens,
			long avgTokensPerSample
	) {
		public ExtendedStatistics {
			failureDistribution = failureDistribution != null
					? Collections.unmodifiableMap(new LinkedHashMap<>(failureDistribution))
					: Collections.emptyMap();
		}
	}

	public static final class Builder {

		private String specId;
		private String useCaseId;
		private int version = 1;
		private Instant generatedAt;
		private Instant approvedAt;
		private String approvedBy;
		private String approvalNotes;
		private List<String> sourceBaselines;
		private Map<String, Object> executionContext;
		private SpecRequirements requirements;
		private CostEnvelope costEnvelope;
		private EmpiricalBasis empiricalBasis;
		private ExtendedStatistics extendedStatistics;

		private Builder() {
		}

		public Builder specId(String specId) {
			this.specId = specId;
			return this;
		}

		public Builder useCaseId(String useCaseId) {
			this.useCaseId = useCaseId;
			return this;
		}

		public Builder version(int version) {
			this.version = version;
			return this;
		}

		public Builder generatedAt(Instant generatedAt) {
			this.generatedAt = generatedAt;
			return this;
		}

		public Builder approvedAt(Instant approvedAt) {
			this.approvedAt = approvedAt;
			return this;
		}

		public Builder approvedBy(String approvedBy) {
			this.approvedBy = approvedBy;
			return this;
		}

		public Builder approvalNotes(String approvalNotes) {
			this.approvalNotes = approvalNotes;
			return this;
		}

		public Builder sourceBaselines(List<String> sourceBaselines) {
			this.sourceBaselines = sourceBaselines;
			return this;
		}

		public Builder executionContext(Map<String, Object> executionContext) {
			this.executionContext = executionContext;
			return this;
		}

		public Builder requirements(SpecRequirements requirements) {
			this.requirements = requirements;
			return this;
		}

		public Builder requirements(double minPassRate, String successCriteria) {
			this.requirements = new SpecRequirements(minPassRate, successCriteria);
			return this;
		}

		public Builder costEnvelope(CostEnvelope costEnvelope) {
			this.costEnvelope = costEnvelope;
			return this;
		}

		public Builder costEnvelope(long maxTimePerSampleMs, long maxTokensPerSample, long totalTokenBudget) {
			this.costEnvelope = new CostEnvelope(maxTimePerSampleMs, maxTokensPerSample, totalTokenBudget);
			return this;
		}

		public Builder empiricalBasis(EmpiricalBasis empiricalBasis) {
			this.empiricalBasis = empiricalBasis;
			return this;
		}

		public Builder empiricalBasis(int samples, int successes, Instant generatedAt) {
			this.empiricalBasis = new EmpiricalBasis(samples, successes, generatedAt);
			return this;
		}

		public Builder empiricalBasis(int samples, int successes) {
			this.empiricalBasis = new EmpiricalBasis(samples, successes, null);
			return this;
		}

		/**
		 * Sets the baseline data.
		 *
		 * @deprecated Use {@link #empiricalBasis(EmpiricalBasis)} instead
		 */
		@Deprecated(since = "0.2.0", forRemoval = true)
		public Builder baselineData(EmpiricalBasis baselineData) {
			this.empiricalBasis = baselineData;
			return this;
		}

		/**
		 * Sets the baseline data from a BaselineData record.
		 *
		 * @deprecated Use {@link #empiricalBasis(EmpiricalBasis)} instead
		 */
		@Deprecated(since = "0.2.0", forRemoval = true)
		public Builder baselineData(BaselineData baselineData) {
			if (baselineData != null) {
				this.empiricalBasis = new EmpiricalBasis(
						baselineData.samples(),
						baselineData.successes(),
						baselineData.generatedAt()
				);
			}
			return this;
		}

		/**
		 * Sets the baseline data.
		 *
		 * @deprecated Use {@link #empiricalBasis(int, int, Instant)} instead
		 */
		@Deprecated(since = "0.2.0", forRemoval = true)
		public Builder baselineData(int samples, int successes, Instant generatedAt) {
			this.empiricalBasis = new EmpiricalBasis(samples, successes, generatedAt);
			return this;
		}

		/**
		 * Sets the baseline data.
		 *
		 * @deprecated Use {@link #empiricalBasis(int, int)} instead
		 */
		@Deprecated(since = "0.2.0", forRemoval = true)
		public Builder baselineData(int samples, int successes) {
			this.empiricalBasis = new EmpiricalBasis(samples, successes, null);
			return this;
		}

		public Builder extendedStatistics(ExtendedStatistics extendedStatistics) {
			this.extendedStatistics = extendedStatistics;
			return this;
		}

		public ExecutionSpecification build() {
			return new ExecutionSpecification(this);
		}
	}
}
